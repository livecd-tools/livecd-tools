#!/usr/bin/python -tt
#
# liveimage-mount: Mount a LiveOS at the specified point, and log
# into a shell.
#
# Copyright 2011, Red Hat  Inc.
#   Code for Live mounting an attached LiveOS device added by Frederick Grose,
#   <fgrose at sugarlabs.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os
import sys
import stat
import getopt
import tempfile
import subprocess

from imgcreate.errors import *

def usage():
    print '''Usage:
        liveimage-mount [opts] ISO|DEVICE  MOUNTPOINT  [command] [args ...]

                  where [opts] = [-h|-?|--help
                                 [-u|--unmount
                                 [-r|--read-only
                                 [--chroot
                                 [--mount-hacks
                                 [--persist
                                 [-o|--overlay=SIZE
                                 [-y|--yumcache=PATH
                                 [-f|--dnfcache=PATH
                                 [-t|--tmpdir=PATH]]]]]]]]]]

                and [args ...] = [arg1[ arg2[ ...]]]

Mount a LiveOS at the specified directory, and log into a command shell.

positional arguments:
  ISO|DEVICE|DIR        A path to the source ISO.iso file, block device,
                          mount point, or directory bearing a LiveOS image.
  MOUNTPOINT            The mount point desired for the LiveOS image's root
                          filesystem.

optional arguments:
  -h, -?, --help        Show this help message and exit.
  -u, --unmount         Specify unmounting a LiveOS image's filesystems.
  -r, --read-only       Specify read-only mounting of image filesystems.
  --chroot              Specify mounting the image root filesystem in a
                          change-root directory.
  --mount-hacks         Specify mounting of the /proc kernel filesystem
                          and /run temporary filesystem.
  --persist             Keep the specified mounts active on exit. (If a
                          command is requested, it will run in the current
                          root filesytem.)

                          Call liveimage-mount -u ISO|DEVICE|DIR  MOUNTPOINT
                          to unmount the image.
  -o SIZE, --overlay SIZE  
                        Specify a size in mebibytes, MiB, for temporary
                          overlay files.  Default is 512 MiB.
  -y PATH, --yumcache PATH  (requires --mount-hacks)
                        Specify bind mounting of a Yum repository directory,
                          otherwise a tmpfs is mounted.
  -f PATH, --dnfcache PATH  (requires --mount-hacks)
                        Specify bind mounting of a DNF repository directory,
                          otherwise a tmpfs is mounted.
  -t PATH, --tmpdir PATH
                        Specify a directory for mounting interim filesystems
                          and holding temporary overlays.

  [command] [args ...]  A shell command with one or more arguments that will
                          be run in a change-root directory.

The optional command and arguments will be run after the LiveOS is mounted.

'''

def sys_exit(ecode):
    """Exit this Python program."""
    sys.exit(ecode)

def call(*popenargs, **kwargs):
    '''
        Calls subprocess.Popen() with the provided arguments.  All stdout and
        stderr output is sent to print.  The return value is the exit
        code of the command.
    '''
    p = subprocess.Popen(*popenargs, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT, **kwargs)
    rc = p.wait()

    # Log output using logging module
    while True:
        # FIXME choose a more appropriate buffer size
        buf = p.stdout.read(4096)
        if not buf:
            break
        print buf

    return rc

def rcall(args, env=None):
    if env:
        environ = os.environ.copy()
        environ.update(env)
    else:
        environ = None
    try:
        p = subprocess.Popen(args, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, env=environ)
        out, err = p.communicate()
    except OSError, e:
        raise CreatorError(u"Failed to execute:\n'%s'\n'%s'" % (args, e))
    except:
        raise CreatorError(u"""Failed to execute:\n'%s'
            \renviron: '%s'\nstdout: '%s'\nstderr: '%s'\nreturncode: '%s'""" %
            (args, environ, out, err, p.returncode))
    else:
        if p.returncode != 0:
            raise CreatorError(u"""Error in call:\n'%s'\nenviron: '%s'
                \rstdout: '%s'\nstderr: '%s'\nreturncode: '%s'""" %
                (args, environ, out, err, p.returncode))
        return out

def lsblk(userargs, ops=None):
    """Use command lsblk from the util-linux package."""

    args = ['lsblk'] + userargs.split()
    if ops:
        ops = ops.split()
        ops.reverse()
        for i in ops:
            args.insert(1, i)
    return rcall(args).strip()

def findmnt(search, ops=None):
    """Use command findmnt from the util-linux package."""

    args = ['findmnt'] + search.split()
    if ops:
        ops = ops.split()
        ops.reverse()
        for i in ops:
            args.insert(1, i)
    return rcall(args).strip()

def mount(userargs, ops=None):
    """Call for a mount with options."""

    args = ['mount'] + userargs
    if ops:
        ops = ops.split()
        for i in ops:
            args.insert(1, i)
    rc = call(args)
    if rc != 0:
        raise CreatorError(u'Return code: %s\n\n**Check for a message '
              'above the Traceback.**\nFailed mount command:\n%s' % (rc, args))

def loop_setup(path, ops=None):
    """Make and associate a loop device with an image file or device."""

    args = ['losetup', '-P', '-f', '--show', path]
    if ops:
        args += ops.split()
    return rcall(args).rstrip()

def losetup(userargs, ops=None):
    """Use command losetup from the util-linux package."""

    args = ['losetup'] + userargs.split()
    if ops:
        ops = ops.split()
        ops.reverse()
        for i in ops:
            args.insert(1, i)
    return rcall(args).strip()

def loop_detach(devloop):
    """Detach a loop device if associated."""

    if devloop and losetup('-nO BACK-FILE ' + devloop):
        losetup('-d ' + devloop)

def cryptsetup(userargs, ops=None):
    """Call cryptsetup with options."""

    args = ['cryptsetup'] + userargs.split()
    if ops:
        args += ops

    rc = call(args)
    if rc != 0:
        raise CreatorError(u'Return code: %s\n**Check for a message '
         'above the Traceback.**\nFailed cryptsetup command:\n%s' % (rc, args))

def dmsetup(userargs, ops=None):
    """Call device-mapper setup with options."""

    args = ['dmsetup'] + userargs.split()
    if ops:
        args += ops

    rc = call(args)
    if rc != 0:
        raise CreatorError(u'Return code: %s\n\n**Check for a message above '
                  'the Traceback.**\nFailed dmsetup command:\n%s' % (rc, args))

def get_dm_table(target):
    """Return the table for a Device-mapper target."""

    table = None
    table = rcall(['dmsetup', 'table', target]).rstrip()
    return table

def link_note(path, rpath):
    """Return a note when paths are linked."""

    linkn = ''
    if os.path.islink(os.path.abspath(path)):
        linkn = "\n      Note: '%s' links to '%s'." % (path, rpath)
    return linkn

def real_directory_path(path, linkn, remove_mp, unmount):
    """Return a real directory path, even for missing or faulty links."""

    rpath = os.path.realpath(path)
    linkn.append(link_note(path, rpath))
    try:
        mode = os.stat(rpath).st_mode
    except OSError as e:
        if e.errno == 2:
            os.makedirs(rpath)
            remove_mp.append(rpath)
            mode = os.stat(rpath).st_mode
        else:
            print >> sys.stderr, '\n    OSError: %s\n%s' % (e, linkn[1])
            sys_exit(1)
    except:
        print 'Unexpected error:', sys.exc_info()[0]
        raise

    if stat.S_ISREG(mode):
        print >> sys.stderr, '''\n    Exiting...
        '%s' is a file and not a directory.\n%s''' % (rpath, linkn[1])
        sys_exit(1)
    elif not stat.S_ISDIR(mode):
        print >> sys.stderr, '''\n    Exiting...
        '%s' is not a directory.\n%s''' % (rpath, linkn[1])
        sys_exit(1)
    elif not unmount and os.path.ismount(rpath):
        src = findmnt('-nro SOURCE ' + rpath)
        print >> sys.stderr, '''\n    Exiting...
        '%s' is already a mount point for these sources:\n
        \r%s\n%s''' % (rpath, src, linkn[1])
        sys_exit(1)

    return rpath


def main():
    if os.geteuid() != 0:
        print >> sys.stderr, """\n  Exiting...
        \r  You must run liveimage-mount with root priviledges.\n"""
        sys_exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h?uro:y:f:t:', ['help',
                                   'unmount', 'read-only', 'chroot',
                                   'mount-hacks', 'persist', 'overlay=',
                                   'yumcache=', 'dnfcache=', 'tmpdir='])
    except getopt.GetoptError as e:
        usage()
        print '  Error:  ' + str(e) + '.\n\tSee usage statement above.'
        sys_exit(1)

    unmount = False
    roflag = ''
    chroot = False
    mount_hacks = False
    persist = False
    osize = 512
    yumcache = ''
    dnfcache = ''
    tmpdir = '/tmp'
    for o, a in opts:
        if o in ('-h', '-?', '--help'):
            usage()
            sys_exit(0)
        elif o in ('-u', '--unmount'):
            unmount = True
        elif o in ('-r', '--read-only'):
            roflag = '-r'
        elif o in ('--chroot', ):
            chroot = True
        elif o in ('--mount-hacks', ):
            mount_hacks = True
        elif o in ('--persist', ):
            persist = True
        elif o in ('-o', '--overlay'):
            try:
                osize = int(a)
            except ValueError:
                print >> sys.stderr, '''\n    Exiting...  Invalid overlay size,
                '%s' is not an integer.\n''' % a
                sys_exit(1)
            else:
                if not osize > 0:
                    print >> sys.stderr, '''
                    Exiting...  Invalid overlay size, '%d' MiB.
                    It must be greater than zero MiB.\n''' % osize
                    sys_exit(1)
        elif o in ('-y', '--yumcache'):
            yumcache = a
            if not os.path.isdir(yumcache):
                print >> sys.stderr, '''\n    Exiting...  Invalid yumcache,
                '%s' is not a directory.\n''' % yumcache
                sys_exit(1)
        elif o in ('-f', '--dnfcache'):
            dnfcache = a
            if not os.path.isdir(dnfcache):
                print >> sys.stderr, '''\n    Exiting...  Invalid dnfcache,
                '%s' is not a directory.\n''' % dnfcache
                sys_exit(1)
        elif o in ('-t', '--tmpdir'):
            tmpdir = a
            if not os.path.isdir(tmpdir):
                print >> sys.stderr, '''\n    Exiting...  Invalid tmpdir,
                '%s' is not a directory.\n''' % tmpdir
                sys_exit(1)

    if len(args) < 2:
        usage()
        print >> sys.stderr, '''  ERROR:
        A LiveOS source AND a mount point must be provided.\n'''
        sys_exit(2)

    def cleanup():
        """Unmount filesystems and remove device-mapper targets and loop
        devices associated with a LiveOS image.
        """

        call(['sync'])
        if os.path.ismount(destmnt):
            call(['umount', '-Rd', destmnt])

        if os.path.exists(os.path.join('/dev', 'mapper', 'Home')):
            dmsetup('remove --retry Home')
            loop_detach(tmphomeoverlayloop)
            if homedev.startswith('/dev/loop'):
                loop_detach(homedev)
        if os.path.exists(os.path.join('/dev', 'mapper', 'EncHome')):
            cryptsetup('close EncHome')
        if os.path.exists(os.path.join('/dev', 'mapper', 'live-rw')):
            dmsetup('remove --retry live-rw')
        loop_detach(tmpoverlayloop)
        if os.path.exists(os.path.join('/dev', 'mapper', 'live-ro')):
            dmsetup('remove --retry live-ro')
        loop_detach(overlayloop)
        if os.path.exists(os.path.join('/dev', 'mapper', 'live-base')):
            dmsetup('remove --retry live-base')
        loop_detach(imgloop)
        if os.path.ismount(squashmnt):
            call(['umount', '-d', squashmnt])
        if os.path.ismount(liveosmnt) and liveosmnt != liveos:
            call(['umount', '-d', liveosmnt])
        [os.rmdir(mp) for mp in remove_mp]
        if not unmount:
            if remountrw:
                mount(['-o', 'remount,rw', liveos, liveosmnt])
            if verbose:
                print 'Cleanup complete.'

    remove_mp = list()
    liveos = os.path.realpath(args[0])
    linkn = [link_note(args[0], liveos)]
    if not os.path.exists(liveos):
        print >> sys.stderr, '''\n    Exiting...
        '%s' is not a file, directory, or device.\n%s''' % (liveos, linkn[0])
        sys_exit(1)
    destmnt = real_directory_path(args[1], linkn, remove_mp, unmount)
    imgloop = ''
    overlayloop = ''
    tmpoverlayloop = ''
    squashmnt = ''

    if unmount:
        if not os.path.ismount(destmnt):
            print >> sys.stderr, "\n  ERROR:\n    '%s' is not a mount point." \
            "  Exiting...\n%s" % (destmnt, linkn[1])
            sys_exit(1)
        src = findmnt('-nro SOURCE ' + destmnt)
        if not src == os.path.join('/dev', 'mapper', 'live-rw'):
            print >> sys.stderr, "\n  ERROR:\n  '%s' is not a LiveOS mount " \
            "point.  Exiting...\n%s" % (destmnt, linkn[1])
            sys_exit(1)
        if os.path.exists(os.path.join('/dev', 'mapper', 'Home')):
            src = get_dm_table('Home').split()
            tmphomeoverlayloop = ''.join(('/dev/loop', src[4].split(':')[1]))
            homedev = src[3]
            if homedev.startswith('7'):
                homedev = ''.join(('/dev/loop', homedev.split(':')[1]))
        if os.path.exists(os.path.join('/dev', 'mapper', 'live-ro')):
            src = get_dm_table('live-ro').split()
            tmpoverlayloop = ''.join(('/dev/loop', src[4].split(':')[1]))
            imgloop = ''.join(('/dev/loop', src[3].split(':')[1]))
        src = get_dm_table('live-rw').split()
        if not imgloop:
            imgloop = ''.join(('/dev/loop', src[3].split(':')[1]))
        overlayloop = ''.join(('/dev/loop', src[4].split(':')[1]))
        liveosmnt = os.path.normpath(losetup('-nO BACK-FILE ' + imgloop)
                                     + '/../..')
        src = findmnt('-nro FSTYPE,SOURCE ' + liveosmnt).split()
        if src[0] == 'squashfs':
            squashmnt = liveosmnt
            remove_mp.append(squashmnt)
            liveosmnt = os.path.normpath(losetup('-nO BACK-FILE ' + src[1])
                                         + '/../..')
        if os.path.ismount(liveosmnt) and liveosmnt != liveos:
            remove_mp.append(liveosmnt)
        src = os.path.join(destmnt, 'mnt', 'live')
        if os.path.ismount(src):
            call(['umount', src])
            os.rmdir(src)
        cleanup()
        print '''\n    '%s' filesystems have been unmounted.\n%s\n
        \r    The '%s' mount point has NOT been deleted.\n%s''' % (
                                           liveos, linkn[0], destmnt, linkn[1])
        if os.path.ismount(liveosmnt) and liveosmnt == liveos:
            print "\n    Note: '%s' may still be read-only mounted.\n" % liveos
        sys_exit(0)

    command = args[2:]
    verbose = not command
    remountrw = False

    if os.path.ismount(liveos) or os.path.isdir(liveos):
        liveosmnt = liveos
    else:
        liveosmnt = tempfile.mkdtemp(prefix='mp-')
        remove_mp.append(liveosmnt)

        if rcall(['file', '-rb', liveos]).startswith('ISO 9660'):
            roflag = '-r'
        elif not lsblk('-nrdo TYPE ' + liveos) == 'part':
            print >> sys.stderr, "\n    Exiting...\n\t'%s' is not a device " \
            "partition or an ISO file.\n%s" % (liveos, linkn[0])
            sys_exit(1)

    try:
        if liveosmnt != liveos:
            mount([liveos, liveosmnt], ops=roflag)

        if not os.access(liveosmnt, os.W_OK):
            roflag = '-r'
        elif roflag:
            if os.path.ismount(liveos):
                mount(['-o', 'remount,ro', liveos, liveosmnt])
                if liveosmnt == liveos:
                    remountrw = True

        liveosdir = os.path.join(liveosmnt, 'LiveOS')
        squash_img = os.path.join(liveosdir, 'squashfs.img')
        if not os.path.exists(squash_img):
            opts = ''
            rootfs_img = os.path.join(liveosdir, 'ext3fs.img')
            if not os.path.exists(rootfs_img):
                rootfs_img = os.path.join(liveosdir, 'rootfs.img')
            if not os.path.exists(rootfs_img):
                print "\n\tNo LiveOS was found on '%s'\n\t  Exiting...\n%s" \
                       % (liveos, linkn[0])
                sys_exit(1)
        else:
            opts = '-r'
            squashmnt = tempfile.mkdtemp(prefix='mp-squash-')
            remove_mp.append(squashmnt)
            mount(['-r', squash_img, squashmnt])
            rootfs_img = os.path.join(squashmnt, 'LiveOS', 'ext3fs.img')
            if not os.path.exists(rootfs_img):
                rootfs_img = os.path.join(squashmnt, 'LiveOS', 'rootfs.img')
            if not os.path.exists(rootfs_img):
                print >> sys.stderr, "\n\tNo rootfs.img was found on '%s'\n" \
                                    "\r\t  Exiting...\n%s" % (liveos, linkn[0])
                sys_exit(1)
        for f in os.listdir(liveosdir):
            if f.find('overlay-') == 0:
                overlayloop = loop_setup(os.path.join(liveosdir, f), roflag)
                opts = '-r'
                break
        imgloop = loop_setup(rootfs_img, opts)
        imgsize = rcall(['blockdev', '--getsz', imgloop]).rstrip()
        dm_path = os.path.join('/dev', 'mapper', 'live-rw')
        dmsetup('create --readonly live-base',
                             ['--table=0 %s linear %s 0' % (imgsize, imgloop)])
        persistent = 'PO'
        if roflag or (not overlayloop and opts):
            persistent = 'N'
            tmpoverlay = tempfile.NamedTemporaryFile(prefix='overlay-')
            print '\npreparing temporary overlay...'
            call(['dd', 'if=/dev/null', 'of=%s' % tmpoverlay.name, 'bs=1024',
                                        'count=1', 'seek=%s' % (osize * 1024)])
            tmpoverlayloop = loop_setup(tmpoverlay.name)
            del tmpoverlay
            if not overlayloop:
                overlayloop = tmpoverlayloop
        dm_roflag = ''
        if roflag and overlayloop != tmpoverlayloop:
            dm_path = os.path.join('/dev', 'mapper', 'live-ro')
            dm_roflag = roflag
        dm_id = os.path.basename(dm_path)
        if not opts and not overlayloop:
            dmsetup('create ' + dm_id, ['--table=0 %s linear %s 0' %
                                        (imgsize, imgloop)])
        else:
            dmsetup('create ' + dm_id, [dm_roflag,
                                        '--table=0 %s snapshot %s %s %s 8' %
                                  (imgsize, imgloop, overlayloop, persistent)])
        if roflag and overlayloop != tmpoverlayloop:
            dmsetup('create live-rw', ['--table=0 %s snapshot %s %s N 8' %
                                       (imgsize, dm_path, tmpoverlayloop)])
        mount([os.path.join('/dev/mapper', 'live-rw'), destmnt])
        home_path = os.path.join(liveosdir, 'home.img')
        if os.path.exists(home_path):
            homemnt = os.path.join(destmnt, 'home')
            if call(['cryptsetup', 'isLuks', home_path]) == 0:
                cryptsetup('open ' + home_path, ['EncHome', roflag])
                home_path = os.path.join('/dev', 'mapper', 'EncHome')
                homedev = home_path
            if roflag or tmpoverlayloop:
                tmpoverlay = tempfile.NamedTemporaryFile(
                             prefix='home-overlay-')
                print '\npreparing temporary home overlay...'
                call(['dd', 'if=/dev/null', 'of=%s' % tmpoverlay.name,
                            'bs=1024', 'count=1', 'seek=%s' % (osize * 1024)])
                tmphomeoverlayloop = loop_setup(tmpoverlay.name)
                del tmpoverlay
                if home_path == os.path.join(liveosdir, 'home.img'):
                    homedev = loop_setup(
                                 os.path.join(liveosdir, 'home.img'), '-r')
                imgsize = rcall(['blockdev', '--getsz', homedev]).rstrip()
                dmsetup('create Home', ['--table=0 %s snapshot %s %s N 8' %
                                       (imgsize, homedev, tmphomeoverlayloop)])
                home_path = os.path.join('/dev', 'mapper', 'Home')
            mount([home_path, homemnt])

        if mount_hacks:
            subprocess.check_call(['mount', '-t', 'proc', 'proc',
                             os.path.join(destmnt, 'proc')], stderr=sys.stderr)
            subprocess.check_call(['mount', '-t', 'tmpfs', 'tmpfs',
                       os.path.join(destmnt, 'run')], stderr=sys.stderr)
            subprocess.check_call(['mount', '-t', 'sysfs', 'sys',
                os.path.join(destmnt, 'sys')], stderr=sys.stderr)
            subprocess.check_call(['mount', '-t', 'devpts', 'devpts',
                os.path.join(destmnt, 'dev', 'pts')], stderr=sys.stderr)
            tmpfs = os.path.join(destmnt, 'dev', 'shm')
            if not os.path.exists(tmpfs):
                os.makedirs(tmpfs)
            subprocess.check_call(['mount', '-t', 'tmpfs', 'tmpfs', tmpfs],
                                  stderr=sys.stderr)
            mount(['--bind', '/etc/resolv.conf',
                   os.path.join(destmnt, 'etc', 'resolv.conf')])
            if yumcache:
                mount(['--bind', yumcache,
                       os.path.join(destmnt, 'var', 'cache', 'yum')])
            else:
                subprocess.check_call(['mount', '-t', 'tmpfs', 'varcacheyum',
                    os.path.join(destmnt, 'var', 'cache', 'yum')],
                    stderr=sys.stderr)
            if dnfcache:
                mount(['--bind', dnfcache,
                       os.path.join(destmnt, 'var', 'cache', 'dnf')])
            elif os.path.exists(os.path.join(destmnt, 'var', 'cache', 'dnf')):
                subprocess.check_call(['mount', '-t', 'tmpfs', 'varcachednf',
                                 os.path.join(destmnt, 'var', 'cache', 'dnf')],
                                 stderr=sys.stderr)

        # Create a mount and a link that appear in the booted environment.
        src = os.path.join(destmnt, 'run', 'initramfs', 'live')
        if not os.path.exists(src):
            os.makedirs(src)
        mount(['--bind', liveosmnt, src])
        src = os.path.join(destmnt, 'run', 'initramfs', 'livedev')
        if os.path.lexists(src):
            os.unlink(src)
        os.symlink(findmnt('-nro SOURCE -T ' + liveosmnt), src)

        mode = "'" + liveos + "' filesystems "
        if tmpoverlayloop:
            mode += 'are only temporary.\n  Changes will NOT persist'
        else:
            mode += 'WILL persist'
        mode += ' after rebooting.'

        if command and persist:
            print '''Starting process with this command line:
                     \r%s\n%s\n''' % (command, 'Changes to ' + mode)
            p = subprocess.Popen(command, close_fds=True)
            print "Process id: %s\n" % p.pid
            ecode = p.returncode
        elif command:
            print 'Entering chroot with command:\n%s\n' % command
            command = ['chroot', destmnt] + command
            ecode = subprocess.call(command, stdin=sys.stdin,
                                    stdout=sys.stdout, stderr=sys.stderr)
            print '\nCommand completed, returned from subprocess.\n'
        elif chroot:
            print 'Starting subshell in a chroot.\n  Changes to ' + mode + '''
            Press Ctrl D to exit...'''
            ecode = subprocess.call(['chroot', destmnt], stdin=sys.stdin,
                                    stdout=sys.stdout, stderr=sys.stderr)
        else:
            print 'Entering subshell...\n  Changes to ' + mode + '''
            Press Ctrl D to exit...'''
            ecode = subprocess.call([os.environ['SHELL']], cwd=destmnt,
                                    stdin=sys.stdin, stdout=sys.stdout,
                                    stderr=sys.stderr)
    finally:
        call(['sync'])
        if persist and os.path.ismount(destmnt):
            print "\n    NOTE: '%s' LiveOS filesystems are still mounted\n" \
            "       at '%s'.\n%s" % (liveos, destmnt, linkn[1])
        elif not persist:
            if verbose:
                print '''Cleaning up...
                Please wait if large files were written.'''
            cleanup()

    sys_exit(ecode)

if __name__ == '__main__':
    main()
