#!/usr/bin/python -tt
# coding: latin-1
# 2015-07-23 13:03:05
#
# liveimage-mount: Mount a LiveOS at the specified point, and log into a shell.
#
# Copyright 2011, 2015 Red Hat, Inc. & Sugar LabsÂ®
#   Code for Live mounting an attached LiveOS device added by Frederick Grose,
#   <fgrose at sugarlabs.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os
import sys
import getopt
import tempfile
import subprocess


def usage(ecode):
    print """Usage:
       liveimage-mount [opts] ISO.iso|LiveOSdev|dir MOUNTPOINT [COMMAND] [ARGS]

                  where [opts] = [-h|--help
                                 [-r|--read-only
                                 [--chroot
                                 [--mount-hacks
                                 [--persist
                                 [-y|--yumcache=YUMCACHEPATH
                                 [-f|--dnfcache=DNFCACHEPATH]]]]]]]

                    and [ARGS] = [arg1[ arg2[ ...]]]\n"""
    sys.exit(ecode)


class LiveImageMountError(Exception):
    """An exception base class for all liveimage-mount errors."""
    def __init__(self, msg):
        Exception.__init__(self, msg)
    def __str__(self):
        try:
            return str(self.message)
        except UnicodeEncodeError:
            return repr(self.message)

    def __unicode__(self):
        return unicode(self.message)


def call(*popenargs, **kwargs):
    """
        Calls subprocess.Popen() with the provided arguments.  All stdout and
        stderr output is sent to print.  The return value is the exit
        code of the command.
    """
    p = subprocess.Popen(*popenargs, stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT, **kwargs)
    rc = p.wait()

    # Log output using logging module
    while True:
        # FIXME choose a more appropriate buffer size
        buf = p.stdout.read(4096)
        if not buf:
            break
        print buf

    return rc


def rcall(args, stdin=None, raise_err=True, env=None):
    """Return stdout, stderr, & returncode from a subprocess call."""

    out, err, p, environ = '', '', None, None
    if env:
        environ = os.environ.copy()
        environ.update(env)
    try:
        p = subprocess.Popen(args, stdin=subprocess.PIPE, env=environ,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate(stdin)
    except OSError as e:
        out, err = out, u'Failed executing:\n%s\nerror: %s' % (args, e)
        if raise_err:
            raise LiveImageMountError(u'Failed executing:\n%s\nerror: %s' %
                                      (args, e))
    except Exception as e:
        out, err = (out, u'Failed to execute:\n%s\nerror: %s' %
                          (args, e))
        if raise_err:
            raise LiveImageMountError(u'''Failed to execute:\n%s
                                      \rerror: %s\nstdout: %s\nstderr: %s''' %
                                      (args, e, out, err))
    else:
        if p.returncode != 0 and raise_err:
            raise LiveImageMountError(u'''Error in call:\n%s\nenviron: %s
                               \rstdout: %s\nstderr: %s\nreturncode: %s''' %
                               (args, environ, out, err, p.returncode))
    finally:
        return out, err


def mount_point(path):
    """Return the mount point for path."""

    while path != os.path.dirname(path):
        if os.path.ismount(path):
            break
        path = os.path.dirname(path)
    return path


def get_mountpoint_device(mountpoint):
    """Return the device for a given mountpoint."""

    args = ['mountpoint', '--fs-devno', mountpoint]
    return rcall(args)[0].rstrip()


def loop_setup(path, ops=None):
    """Make and associate a loop device with an image file or device."""

    args = ['losetup', '-P', '-f', '--show', path]
    if ops:
        args += ops.split()
    return rcall(args)[0].rstrip()


def mount(userargs, ops=None):
    """Call for a mount with options."""

    args = ['mount'] + userargs
    if ops:
        ops = ops.split()
        ops.reverse()
        for i in ops:
            args.insert(1, i)
    return call(args)


def main():
    if os.geteuid() != 0:
        print >> sys.stderr, """\n  Exiting...
        \r  You must run liveimage-mount with root priviledges.\n"""
        return 1

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hry:f:', ['help', 'read-only',
                 'chroot', 'persist', 'mount-hacks', 'yumcache=', 'dnfcache='])
    except getopt.GetoptError, e:
        usage(1)

    cwd = os.getcwd()
    roflag = ''
    chroot = False
    mount_hacks = False
    persist = False
    yumcache = None
    dnfcache = None
    for o, a in opts:
        if o in ('-h', '--help'):
            usage(0)
        elif o in ('-r', '--read-only'):
            roflag = '-r'
        elif o in ('--chroot',):
            chroot = True
        elif o in ('--mount-hacks',):
            mount_hacks = True
        elif o in ('--persist',):
            """Option used to run a command in a spawned process."""
            persist = True
        elif o in ('-y', '--yumcache'):
            yumcache = a
        elif o in ('-f', '--dnfcache'):
            dnfcache = a

    if len(args) < 2:
        usage(1)

    liveos = args[0]
    destmnt = args[1]
    remove_mp = tuple()
    if not os.path.isdir(destmnt):
        os.makedirs(destmnt)
        remove_mp += (destmnt,)
    if os.path.ismount(destmnt):
        print """\n     Exiting...
        %s is already in use as a mount point.\n""" % destmnt
        ecode = 1
        return

    if not os.path.exists(liveos):
        print """\n     Exiting...
        %s is not a file, directory, or device.\n""" % liveos
        ecode = 1
        return

    command = args[2:]
    verbose = not command

    try:
        if os.path.ismount(liveos) or os.path.isdir(liveos):
            liveosmnt = liveos
        else:
            liveosmnt = tempfile.mkdtemp(prefix='mp-', dir='/run')
            remove_mp += (liveosmnt,)
            mount([liveos, liveosmnt], ops=roflag)

        if not os.access(liveosmnt, os.W_OK):
            roflag = '-r'
        elif roflag:
            if os.path.ismount(liveos):
                mount(['-o', 'remount,ro', liveos, liveosmnt])
                if liveosmnt == liveos:
                    remountrw = True

        liveosdir = os.path.join(liveosmnt, 'LiveOS')

        squash_img = os.path.join(liveosdir, 'squashfs.img')
        if not os.path.exists(squash_img):
            rootfs_img = os.path.join(liveosdir, 'ext3fs.img')
            if not os.path.exists(rootfs_img):
                print """
                \r\tNo LiveOS was found on %s\n\t  Exiting...\n""" % liveos
                ecode = 1
                return
        else:
            squashmnt = tempfile.mkdtemp(prefix='mp-squash-', dir='/run')
            remove_mp += (squashmnt,)
            mount(['-r', squash_img, squashmnt])
            rootfs_img = os.path.join(squashmnt, 'LiveOS', 'ext3fs.img')
            if not os.path.exists(rootfs_img):
                rootfs_img = os.path.join(squashmnt, 'LiveOS', 'rootfs.img')
            if not os.path.exists(rootfs_img):
                print """
                \r\tNo rootfs.img was found on %s\n\t  Exiting...\n""" % liveos
                ecode = 1
                return

        imgloop = loop_setup(rootfs_img, '-r')
        imgsize = rcall(['blockdev', '--getsz', imgloop])[0].rstrip()
        dm_path = os.path.join('/dev', 'mapper', 'live-rw')
        X = ''
        if os.path.exists(dm_path):
            fd, X = tempfile.mkstemp(prefix='live-rw-', dir='/dev/mapper')
            os.close(fd)
            os.unlink(X)
            X = ''.join(('-', os.path.basename(X)[8:]))
            dm_path += X
        call(['dmsetup', 'create', '--readonly', 'live-base' + X,
                              '--table=0 %s linear %s 0' % (imgsize, imgloop)])
        for f in os.listdir(liveosdir):
            if f.find('overlay-') == 0:
                overlayloop = loop_setup(os.path.join(liveosdir, f))
                break
        persistent = 'P'
        if roflag or 'overlayloop' not in locals():
            persistent = 'N'
            tmpoverlay = tempfile.NamedTemporaryFile(prefix='tmp-overlay-',
                                                     dir='/run')
            print "\npreparing temporary overlay..."
            call(['dd', 'if=/dev/null', 'of=%s' % tmpoverlay.name, 'bs=1024',
                                        'count=1', 'seek=%s' % (512 * 1024)])
            tmpoverlayloop = loop_setup(tmpoverlay.name)
            del tmpoverlay
            if 'overlayloop' not in locals():
                overlayloop = tmpoverlayloop
        dm_roflag = ''
        if roflag and overlayloop != tmpoverlayloop:
            dm_path = os.path.join('/dev', 'mapper', 'live-ro' + X)
            dm_roflag = roflag
        dm_id = os.path.basename(dm_path)
        call(['dmsetup', 'create', dm_id, dm_roflag,
                                  '--table=0 %s snapshot %s %s %s 8' %
                                  (imgsize, imgloop, overlayloop, persistent)])
        if roflag and overlayloop != tmpoverlayloop:
            call(['dmsetup', 'create', 'live-rw' + X,
                                         '--table=0 %s snapshot %s %s N 8'
                                         % (imgsize, dm_path, tmpoverlayloop)])
        mount([os.path.join('/dev/mapper', 'live-rw' + X), destmnt])
        home_path = os.path.join(liveosdir, 'home.img')
        if os.path.exists(home_path):
            homemnt = os.path.join(destmnt, 'home')
            if call(['cryptsetup', 'isLuks', home_path]) == 0:
                call(['cryptsetup', 'open', home_path, 'EncHome' + X, roflag])
                home_path = os.path.join('/dev', 'mapper', 'EncHome' + X)
                homedev = home_path
            if roflag or 'tmpoverlayloop' in locals():
                tmpoverlay = tempfile.NamedTemporaryFile(
                             prefix='tmp-home-overlay-', dir='/run')
                print "\npreparing temporary home overlay..."
                call(['dd', 'if=/dev/null', 'of=%s' % tmpoverlay.name,
                               'bs=1024', 'count=1', 'seek=%s' % (512 * 1024)])
                tmphomeoverlayloop = loop_setup(tmpoverlay.name)
                del tmpoverlay
                if home_path == os.path.join(liveosdir, 'home.img'):
                    homedev = loop_setup(
                                     os.path.join(liveosdir, 'home.img'), '-r')
                imgsize = rcall(['blockdev', '--getsz', homedev])[0].rstrip()
                call(['dmsetup', 'create', 'Home' + X,
                                            '--table=0 %s snapshot %s %s N 8' %
                                       (imgsize, homedev, tmphomeoverlayloop)])
                home_path = os.path.join('/dev', 'mapper', 'Home' + X)
            mount([home_path, homemnt])

        # Create a mount and a link that appear in the booted environment.
        mntlive = os.path.join(destmnt, 'run', 'initramfs', 'live')
        if not os.path.exists(mntlive):
            os.makedirs(mntlive)
        mount(['--bind', liveosmnt, mntlive])
        livedevlink = os.path.join(destmnt, 'run', 'initramfs', 'livedev')
        if os.path.lexists(livedevlink):
            os.unlink(livedevlink)
        os.symlink(os.path.join('/dev', os.path.basename(os.readlink(
                             os.path.join('/dev', 'block',
                             get_mountpoint_device(mount_point(liveosmnt)))))),
                             livedevlink)

        if mount_hacks:
            subprocess.check_call(['mount', '-t', 'proc', 'proc',
                os.path.join(destmnt, 'proc')], stderr=sys.stderr)
            subprocess.check_call(['mount', '-t', 'sysfs', 'sys',
                os.path.join(destmnt, 'sys')], stderr=sys.stderr)
            subprocess.check_call(['mount', '-t', 'devpts', 'devpts',
                os.path.join(destmnt, 'dev', 'pts')], stderr=sys.stderr)
            tmpfs = os.path.join(destmnt, 'dev', 'shm')
            if not os.path.exists(tmpfs):
                os.makedirs(tmpfs)
            subprocess.check_call(['mount', '-t', 'tmpfs', 'tmpfs', tmpfs],
                                  stderr=sys.stderr)
            mount(['--bind', '/etc/resolv.conf',
                   os.path.join(destmnt, 'etc', 'resolv.conf')])
            if yumcache:
                mount(['--bind', yumcache,
                       os.path.join(destmnt, 'var', 'cache', 'yum')])
            else:
                subprocess.check_call(['mount', '-t', 'tmpfs', 'varcacheyum',
                    os.path.join(destmnt, 'var', 'cache', 'yum')],
                    stderr=sys.stderr)
            if dnfcache:
                mount(['--bind', dnfcache,
                       os.path.join(destmnt, 'var', 'cache', 'dnf')])
            elif os.path.exists(os.path.join(destmnt, 'var', 'cache', 'dnf')):
                subprocess.check_call(['mount', '-t', 'tmpfs', 'varcachednf',
                                 os.path.join(destmnt, 'var', 'cache', 'dnf')],
                                 stderr=sys.stderr)

        mode = liveos + ' filesystems '
        if 'tmpoverlayloop' in locals():
            mode += 'are only temporary.\n  Changes will NOT persist'
        else:
            mode += 'WILL persist'
        mode += ' afer rebooting.'

        if len(command) > 0 and persist:
            args = []
            args.extend(command)
            print """Starting process with this command line:
                     \r%s\n%s\n""" % (command, 'Changes to ' + mode)
            p = subprocess.Popen(args, close_fds=True)
            print "Process id: %s\n" % p.pid
            ecode = p.returncode
        elif len(command) > 0:
            args = ['chroot', destmnt]
            args.extend(command)
            ecode = subprocess.call(args, stdin=sys.stdin, stdout=sys.stdout,
                                    stderr=sys.stderr)
        elif chroot:
            print 'Starting subshell in a chroot.\n  Changes to ' + mode + """
            Press Ctrl D to exit..."""
            ecode = subprocess.call(['chroot', destmnt], stdin=sys.stdin,
                                    stdout=sys.stdout, stderr=sys.stderr)
        else:
            print 'Entering subshell...\n  Changes to ' + mode + """
            Press Ctrl D to exit..."""
            ecode = subprocess.call([os.environ['SHELL']], cwd=destmnt,
                    stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
    finally:
        if verbose:
            print """Cleaning up...
            Please wait if large files were written."""
        call(['sync'])
        os.chdir(cwd)
        if not persist:
            if os.path.ismount(mntlive):
                call(['umount', mntlive])
            if mount_hacks:
                call(['umount', os.path.join(destmnt, 'proc'),
                                os.path.join(destmnt, 'dev', 'pts'),
                                os.path.join(destmnt, 'sys'),
                                os.path.join(destmnt, 'dev', 'shm'),
                                os.path.join(destmnt, 'var', 'cache', 'yum'),
                                os.path.join(destmnt, 'var', 'cache', 'dnf'),
                                os.path.join(destmnt, 'etc', 'resolv.conf')])

            if os.path.exists(home_path):
                call(['umount', '-d', homemnt])
                if os.path.exists(os.path.join('/dev', 'mapper', 'Home' + X)):
                    call(['dmsetup', 'remove', '--retry', 'Home' + X])
                    call(['losetup', '-d', tmphomeoverlayloop])
                    if homedev.startswith('/dev/loop'):
                        call(['losetup', '-d', homedev])
                if os.path.exists(
                           os.path.join('/dev', 'mapper', 'EncHome' + X)):
                    call(['cryptsetup', 'close', 'EncHome' + X])
            if os.path.ismount(destmnt):
                call(['umount', destmnt])
            call(['dmsetup', 'remove', '--retry', 'live-rw' + X])
            if roflag and overlayloop != tmpoverlayloop:
                call(['dmsetup', 'remove', '--retry', 'live-ro' + X])
                call(['losetup', '-d', tmpoverlayloop])
            call(['losetup', '-d', overlayloop])
            call(['dmsetup', 'remove', '--retry', 'live-base' + X])
            call(['losetup', '-d', imgloop])
            if os.path.exists(squash_img):
                call(['umount', '-d', squashmnt])
            if os.path.ismount(liveosmnt) and liveosmnt != liveos:
                call(['umount', '-d', liveosmnt])
            [os.rmdir(mp) for mp in remove_mp]
            if 'remountrw' in locals():
                mount(['-o', 'remount,rw', liveos, liveosmnt])
            if verbose:
                print 'Cleanup complete.'

    sys.exit(ecode)

if __name__ == '__main__':
    main()
